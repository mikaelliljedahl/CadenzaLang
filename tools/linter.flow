// FlowLang Static Analysis and Linting Tool
// Comprehensive linting implemented in FlowLang itself
// This replaces the broken LintCommand from src/flowc.cs

module Linter {
    uses [FileSystem, IO]

    // Linting configuration
    function LintConfig(
        rules_enabled: List<string>,
        severity_threshold: string,
        output_format: string,
        auto_fix: bool
    ) -> LintConfig {
        return LintConfig {
            enabled_rules: rules_enabled,
            min_severity: severity_threshold,
            format: output_format,
            should_auto_fix: auto_fix
        }
    }

    // Main entry point for linting
    function run_linter(args: List<string>) uses [FileSystem, IO] -> Result<int, LintError> {
        let config = parse_lint_args(args)?
        let files = discover_flow_files(config.target_paths)?
        
        if config.verbose {
            log_info($"Linting {files.length} FlowLang files...")
        }
        
        let all_issues = List.empty<LintIssue>()
        let total_files = 0
        let files_with_issues = 0
        
        for file_path in files {
            let file_issues = lint_file(file_path, config)?
            
            if file_issues.length > 0 {
                files_with_issues = files_with_issues + 1
                all_issues = all_issues.append_all(file_issues)
            }
            
            total_files = total_files + 1
        }
        
        // Generate report
        let report = create_lint_report(all_issues, total_files, files_with_issues)
        output_report(report, config)?
        
        // Return appropriate exit code
        let error_count = count_issues_by_severity(all_issues, "error")
        if error_count > 0 {
            return Ok(1) // Exit code 1 for errors
        } else {
            return Ok(0) // Exit code 0 for success
        }
    }

    // Parse command line arguments for linter
    function parse_lint_args(args: List<string>) -> Result<LintConfig, ArgError> {
        let target_paths = List.empty<string>()
        let rules_enabled = get_default_rules()
        let severity = "warning"
        let format = "text"
        let auto_fix = false
        let verbose = false
        
        for arg in args {
            if arg == "--auto-fix" {
                auto_fix = true
            } else if arg == "--verbose" || arg == "-v" {
                verbose = true
            } else if arg.starts_with("--format=") {
                format = arg.substring(9)
            } else if arg.starts_with("--severity=") {
                severity = arg.substring(11)
            } else if arg.starts_with("--rules=") {
                let rules_str = arg.substring(8)
                rules_enabled = rules_str.split(",")
            } else if arg.ends_with(".flow") || is_directory(arg) {
                target_paths = target_paths.append(arg)
            }
        }
        
        if target_paths.is_empty() {
            target_paths = target_paths.append(".") // Default to current directory
        }
        
        return Ok(LintConfig(rules_enabled, severity, format, auto_fix, target_paths, verbose))
    }

    // Get default enabled linting rules
    function get_default_rules() -> List<string> {
        return [
            "effect_usage_validation",
            "result_type_analysis", 
            "unused_variables",
            "dead_code_detection",
            "complexity_analysis",
            "security_analysis",
            "performance_hints",
            "naming_conventions",
            "documentation_coverage",
            "pure_function_validation"
        ]
    }

    // Lint a single FlowLang file
    function lint_file(file_path: string, config: LintConfig) uses [FileSystem] -> Result<List<LintIssue>, LintError> {
        let source_code = read_file(file_path)?
        let issues = List.empty<LintIssue>()
        
        // Parse the FlowLang source (simplified - would use real parser)
        let parse_result = parse_flowlang_source(source_code)
        
        match parse_result {
            Ok(ast) -> {
                // Run each enabled rule
                for rule_name in config.enabled_rules {
                    let rule_issues = run_lint_rule(rule_name, ast, file_path, source_code)?
                    issues = issues.append_all(rule_issues)
                }
            }
            Error(parse_error) -> {
                // Add parse error as a critical issue
                let issue = LintIssue {
                    file_path: file_path,
                    line: parse_error.line,
                    column: parse_error.column,
                    rule: "syntax_error",
                    severity: "error",
                    message: parse_error.message,
                    suggestion: null
                }
                issues = issues.append(issue)
            }
        }
        
        return Ok(issues)
    }

    // Run a specific linting rule
    function run_lint_rule(
        rule_name: string, 
        ast: Program, 
        file_path: string, 
        source: string
    ) -> Result<List<LintIssue>, LintError> {
        
        return match rule_name {
            "effect_usage_validation" -> validate_effect_usage(ast, file_path)
            "result_type_analysis" -> analyze_result_types(ast, file_path)
            "unused_variables" -> find_unused_variables(ast, file_path)
            "dead_code_detection" -> detect_dead_code(ast, file_path)
            "complexity_analysis" -> analyze_complexity(ast, file_path)
            "security_analysis" -> analyze_security_issues(ast, file_path)
            "performance_hints" -> analyze_performance(ast, file_path)
            "naming_conventions" -> check_naming_conventions(ast, file_path)
            "documentation_coverage" -> check_documentation(ast, file_path, source)
            "pure_function_validation" -> validate_pure_functions(ast, file_path)
            _ -> Ok(List.empty<LintIssue>())
        }
    }

    // Effect usage validation rule
    function validate_effect_usage(ast: Program, file_path: string) -> Result<List<LintIssue>, LintError> {
        let issues = List.empty<LintIssue>()
        
        for statement in ast.statements {
            if statement is FunctionDeclaration {
                let func = statement as FunctionDeclaration
                
                // Check if function uses effects but doesn't declare them
                let body_effects = analyze_function_body_effects(func.body)
                let declared_effects = func.effects or List.empty<string>()
                
                for effect in body_effects {
                    if not declared_effects.contains(effect) {
                        let issue = LintIssue {
                            file_path: file_path,
                            line: func.line,
                            column: func.column,
                            rule: "effect_usage_validation",
                            severity: "error",
                            message: $"Function '{func.name}' uses effect '{effect}' but doesn't declare it",
                            suggestion: $"Add 'uses [{ declared_effects.append(effect).join(\", \") }]' to function signature"
                        }
                        issues = issues.append(issue)
                    }
                }
                
                // Check for unused declared effects
                for declared_effect in declared_effects {
                    if not body_effects.contains(declared_effect) {
                        let issue = LintIssue {
                            file_path: file_path,
                            line: func.line,
                            column: func.column,
                            rule: "effect_usage_validation",
                            severity: "warning",
                            message: $"Function '{func.name}' declares effect '{declared_effect}' but doesn't use it",
                            suggestion: "Remove unused effect declaration"
                        }
                        issues = issues.append(issue)
                    }
                }
            }
        }
        
        return Ok(issues)
    }

    // Result type analysis rule
    function analyze_result_types(ast: Program, file_path: string) -> Result<List<LintIssue>, LintError> {
        let issues = List.empty<LintIssue>()
        
        for statement in ast.statements {
            if statement is FunctionDeclaration {
                let func = statement as FunctionDeclaration
                
                // Check if function has side effects but doesn't return Result
                if func.effects != null && func.effects.length > 0 {
                    if func.return_type != null && not func.return_type.starts_with("Result<") {
                        let issue = LintIssue {
                            file_path: file_path,
                            line: func.line,
                            column: func.column,
                            rule: "result_type_analysis",
                            severity: "warning",
                            message: $"Function '{func.name}' has side effects but doesn't return Result type",
                            suggestion: "Consider returning Result<T, Error> for better error handling"
                        }
                        issues = issues.append(issue)
                    }
                }
                
                // Check for proper error propagation
                let propagation_issues = check_error_propagation(func.body, file_path)
                issues = issues.append_all(propagation_issues)
            }
        }
        
        return Ok(issues)
    }

    // Performance analysis rule
    function analyze_performance(ast: Program, file_path: string) -> Result<List<LintIssue>, LintError> {
        let issues = List.empty<LintIssue>()
        
        for statement in ast.statements {
            if statement is FunctionDeclaration {
                let func = statement as FunctionDeclaration
                
                // Check for potential performance issues
                let perf_issues = analyze_function_performance(func, file_path)
                issues = issues.append_all(perf_issues)
            }
        }
        
        return Ok(issues)
    }

    // Security analysis rule
    function analyze_security_issues(ast: Program, file_path: string) -> Result<List<LintIssue>, LintError> {
        let issues = List.empty<LintIssue>()
        
        // Check for common security anti-patterns
        let security_issues = find_security_patterns(ast, file_path)
        issues = issues.append_all(security_issues)
        
        return Ok(issues)
    }

    // Create comprehensive lint report
    function create_lint_report(
        issues: List<LintIssue>, 
        total_files: int, 
        files_with_issues: int
    ) -> LintReport {
        
        let error_count = count_issues_by_severity(issues, "error")
        let warning_count = count_issues_by_severity(issues, "warning")
        let info_count = count_issues_by_severity(issues, "info")
        
        return LintReport {
            total_files: total_files,
            files_with_issues: files_with_issues,
            total_issues: issues.length,
            error_count: error_count,
            warning_count: warning_count,
            info_count: info_count,
            issues: issues,
            timestamp: current_timestamp()
        }
    }

    // Output report in specified format
    function output_report(report: LintReport, config: LintConfig) uses [IO] -> Result<Unit, OutputError> {
        return match config.format {
            "text" -> output_text_report(report)
            "json" -> output_json_report(report)
            "sarif" -> output_sarif_report(report)
            _ -> Error(OutputError($"Unsupported output format: {config.format}"))
        }
    }

    // Output text format report
    function output_text_report(report: LintReport) uses [IO] -> Result<Unit, OutputError> {
        print("FlowLang Linting Report")
        print("======================")
        print()
        print($"Files analyzed: {report.total_files}")
        print($"Files with issues: {report.files_with_issues}")
        print($"Total issues: {report.total_issues}")
        print($"  Errors: {report.error_count}")
        print($"  Warnings: {report.warning_count}")
        print($"  Info: {report.info_count}")
        print()
        
        if report.issues.length > 0 {
            print("Issues:")
            print("-------")
            
            for issue in report.issues {
                let severity_icon = match issue.severity {
                    "error" -> "✗"
                    "warning" -> "⚠"
                    "info" -> "ℹ"
                    _ -> "•"
                }
                
                print($"{severity_icon} {issue.file_path}:{issue.line}:{issue.column}")
                print($"  [{issue.rule}] {issue.message}")
                
                if issue.suggestion != null {
                    print($"  Suggestion: {issue.suggestion}")
                }
                print()
            }
        }
        
        return Ok(Unit)
    }

    // Utility functions for rule implementation
    function analyze_function_body_effects(body: List<ASTNode>) -> List<string> {
        // Simplified effect analysis - would be more comprehensive
        let effects = List.empty<string>()
        
        for statement in body {
            if statement is CallExpression {
                let call = statement as CallExpression
                
                // Check for known effect-using functions
                if call.name.contains("read_file") || call.name.contains("write_file") {
                    effects = effects.append("FileSystem")
                } else if call.name.contains("http_") || call.name.contains("fetch") {
                    effects = effects.append("Network")
                } else if call.name.contains("log_") || call.name.contains("print") {
                    effects = effects.append("Logging")
                }
            }
        }
        
        return effects.distinct()
    }

    function count_issues_by_severity(issues: List<LintIssue>, severity: string) -> int {
        return issues.filter(issue -> issue.severity == severity).length
    }
}

// Entry point for the linter tool
function main(args: List<string>) uses [FileSystem, IO] -> Result<int, Error> {
    match Linter.run_linter(args) {
        Ok(exit_code) -> return Ok(exit_code)
        Error(lint_error) -> {
            print($"Linter error: {lint_error}")
            return Ok(1)
        }
    }
}