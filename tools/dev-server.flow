// FlowLang Development Server
// Hot-reload development server implemented in FlowLang itself
// This replaces the broken DevCommand from src/flowc.cs

module DevServer {
    uses [FileSystem, Network, Process]

    // Configuration for the development server
    function ServerConfig(port: int, watch_dir: string, verbose: bool) -> ServerConfig {
        return ServerConfig {
            port: port,
            watch_directory: watch_dir,
            verbose_logging: verbose,
            websocket_port: port + 1
        }
    }

    // Main entry point for development server
    function start_dev_server(args: List<string>) uses [FileSystem, Network, Process] -> Result<Unit, ServerError> {
        let config = parse_dev_args(args)?
        
        if config.verbose_logging {
            log_info("Starting FlowLang development server...")
            log_info($"Port: {config.port}")
            log_info($"Watching: {config.watch_directory}")
        }
        
        // Initialize file watcher
        let watcher = create_file_watcher(config.watch_directory)?
        
        // Start HTTP server for static files
        let http_server = create_http_server(config.port)?
        
        // Start WebSocket server for hot reload
        let ws_server = create_websocket_server(config.websocket_port)?
        
        // Generate initial HTML template
        generate_dev_template(config)?
        
        if config.verbose_logging {
            log_info($"Development server running at http://localhost:{config.port}")
            log_info("Press Ctrl+C to stop")
        }
        
        // Main server loop
        return run_dev_loop(watcher, http_server, ws_server, config)
    }

    // Parse command line arguments for dev server
    function parse_dev_args(args: List<string>) -> Result<ServerConfig, ArgError> {
        let port = 8080
        let watch_dir = "."
        let verbose = false
        
        // Simple argument parsing
        for arg in args {
            if arg == "--verbose" || arg == "-v" {
                verbose = true
            } else if arg.starts_with("--port=") {
                let port_str = arg.substring(7)
                port = parse_int(port_str)?
            } else if arg.starts_with("--watch=") {
                watch_dir = arg.substring(8)
            }
        }
        
        return Ok(ServerConfig(port, watch_dir, verbose))
    }

    // Main development server loop
    function run_dev_loop(
        watcher: FileWatcher, 
        http_server: HttpServer, 
        ws_server: WebSocketServer,
        config: ServerConfig
    ) uses [FileSystem, Network, Process] -> Result<Unit, ServerError> {
        
        while true {
            // Check for file changes
            let changes = watcher.poll_changes()?
            
            for change in changes {
                if change.file_path.ends_with(".flow") {
                    if config.verbose_logging {
                        log_info($"File changed: {change.file_path}")
                    }
                    
                    // Attempt compilation
                    let compile_result = compile_flowlang_file(change.file_path)
                    
                    match compile_result {
                        Ok(output) -> {
                            // Send success update via WebSocket
                            let update = create_hot_reload_update("success", output, null)
                            ws_server.broadcast(update)?
                            
                            if config.verbose_logging {
                                log_info("Compilation successful, hot reload sent")
                            }
                        }
                        Error(compile_error) -> {
                            // Send error update via WebSocket
                            let update = create_hot_reload_update("error", "", compile_error)
                            ws_server.broadcast(update)?
                            
                            if config.verbose_logging {
                                log_error($"Compilation failed: {compile_error}")
                            }
                        }
                    }
                }
            }
            
            // Handle HTTP requests
            let http_requests = http_server.poll_requests()?
            for request in http_requests {
                handle_http_request(request, config)?
            }
            
            // Small delay to prevent busy waiting
            sleep_ms(50)
        }
        
        return Ok(Unit)
    }

    // Compile a FlowLang file using the core transpiler
    function compile_flowlang_file(file_path: string) uses [Process] -> Result<string, CompileError> {
        let temp_output = $"/tmp/hot_reload_{random_id()}.cs"
        
        // Call the core transpiler
        let result = execute_process("../core/bin/Debug/net8.0/flowc-core", [file_path, temp_output])
        
        match result {
            Ok(exit_code) -> {
                if exit_code == 0 {
                    // Read the generated C# code
                    let cs_code = read_file(temp_output)?
                    delete_file(temp_output) // Cleanup
                    return Ok(cs_code)
                } else {
                    return Error(CompileError("Transpilation failed"))
                }
            }
            Error(process_error) -> {
                return Error(CompileError($"Process execution failed: {process_error}"))
            }
        }
    }

    // Create hot reload update message
    function create_hot_reload_update(status: string, code: string, error: CompileError?) -> string {
        return json_encode({
            "type": "hot_reload",
            "status": status,
            "code": code,
            "error": error?.message,
            "timestamp": current_timestamp()
        })
    }

    // Handle HTTP requests for static files
    function handle_http_request(request: HttpRequest, config: ServerConfig) uses [FileSystem] -> Result<Unit, HttpError> {
        match request.path {
            "/" -> {
                // Serve the development HTML template
                let html = generate_dev_html(config)
                return request.respond_html(html)
            }
            path if path.starts_with("/static/") -> {
                // Serve static files
                let file_path = $".{path}"
                if file_exists(file_path) {
                    let content = read_file(file_path)?
                    return request.respond_file(content, get_mime_type(path))
                } else {
                    return request.respond_404()
                }
            }
            _ -> {
                return request.respond_404()
            }
        }
    }

    // Generate the development HTML template with hot reload support
    function generate_dev_html(config: ServerConfig) -> string {
        return $"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>FlowLang Development Server</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .status {{ padding: 10px; margin: 10px 0; border-radius: 4px; }}
                .success {{ background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }}
                .error {{ background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }}
                pre {{ background: #f8f9fa; padding: 15px; border-radius: 4px; overflow-x: auto; }}
            </style>
        </head>
        <body>
            <h1>FlowLang Development Server</h1>
            <div id="status" class="status">Ready - watching for changes...</div>
            <div id="output"></div>
            
            <script>
                const ws = new WebSocket('ws://localhost:{config.websocket_port}');
                const status = document.getElementById('status');
                const output = document.getElementById('output');
                
                ws.onmessage = function(event) {{
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'hot_reload') {{
                        if (data.status === 'success') {{
                            status.className = 'status success';
                            status.textContent = 'Compilation successful ✓';
                            output.innerHTML = '<h3>Generated C#:</h3><pre>' + 
                                             data.code.replace(/</g, '&lt;').replace(/>/g, '&gt;') + 
                                             '</pre>';
                        }} else {{
                            status.className = 'status error';
                            status.textContent = 'Compilation failed ✗';
                            output.innerHTML = '<h3>Error:</h3><pre>' + data.error + '</pre>';
                        }}
                    }}
                }};
                
                ws.onopen = function() {{
                    status.textContent = 'Connected - watching for changes...';
                }};
                
                ws.onclose = function() {{
                    status.className = 'status error';
                    status.textContent = 'Connection lost - please restart server';
                }};
            </script>
        </body>
        </html>
        """
    }

    // Utility functions (would be implemented in standard library)
    function log_info(message: string) uses [IO] -> Unit {
        print($"[INFO] {current_time()}: {message}")
    }

    function log_error(message: string) uses [IO] -> Unit {
        print($"[ERROR] {current_time()}: {message}")
    }

    function random_id() -> string {
        // Simple random ID generation
        return $"{current_timestamp()}_{random_number(1000, 9999)}"
    }
}

// Entry point for the development server tool
function main(args: List<string>) uses [FileSystem, Network, Process] -> Result<int, Error> {
    match DevServer.start_dev_server(args) {
        Ok(_) -> return Ok(0)
        Error(server_error) -> {
            print($"Development server error: {server_error}")
            return Ok(1)
        }
    }
}